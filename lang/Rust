use rand::Rng;
let mut rng =rand::thread_rng();
let j=rng.gen_range(0,N);


use std::time::{Duration, SystemTime};
let sy_time = SystemTime::now();
println!("{:?}", sy_time.elapsed().unwrap().as_millis() );

//环境变量
&env::var( "OMP_NUM_THREADS" ).unwrap();

if let Some(ref p) = self.path {}
          
//全局变量
static mut THE_SERIAL_PORT: SerialPort = SerialPort;
fn main() {
    let _ = unsafe {
        THE_SERIAL_PORT.read_speed();
    };
}

for ch in 'a'..='z' {
  print!("{}",ch);
}

println!("{}", 1); // 默认用法,打印Display
println!("{:o}", 9); // 八进制
println!("{:x}", 255); // 十六进制 小写
println!("{:X}", 255); // 十六进制 大写
println!("{:p}", &0); // 指针
println!("{:b}", 15); // 二进制
println!("{:e}", 10000f32); // 科学计数(小写)
println!("{:E}", 10000f32); // 科学计数(大写)
println!("{:?}", "test"); // 打印Debug
println!("{:#?}", ("test1", "test2")); // 带换行和缩进的Debug打印
println!("{a} {b} {b}", a = "x", b = "y"); // 命名参数

# string add string
let mut s1 = "Hello,".to_string();
let s2 = "world".to_string();
s1 += &s2;

# iterator on string
for c in my_str.chars() {
    // do something with `c`
}

if let Some([b'@', filename @ ..]) = Some(b"@abc123") {
  println!("filename {:?}", filename);
}

format!("{}{}","hello","world")

# 打印长数组
let a = [0; 33];
println!("{:?}", &a[..]);

# concat vector
let concatenated = [&first[..], &second[..]].concat();

#做参数时,用&[u8]好于&Vec<u8>
Vec<u8> to [u8]  Vec<u8>.as_slice()


#[inline]
#[inline(always)]

export RUST_LOG=info

let range = 0..100;
let a = repeat(3);
range.zip(a).flat_map(|(i, j)| {
  once(i).chain(once(j))
})

(0..).take(10).filter(|x|x%2==0)

pub fn max_coins(piles: Vec<i32>) -> i32 {
    let mut pp=piles.clone();
    pp.sort();
    let l=2*(pp.len()/3);
    let mut it=pp.into_iter().rev().take(l);
    it.next();

    let mut sum:i32=0;

    loop{
        match it.next(){
            Some(x)=>{
                sum+=x;
                it.next();
            }
            None=>{
                return sum;
            }
        }
    }
}


Rust         | Cpp              |                      
=============|==================|=====================|=======================
a:&T         | const T* const a | 都不能修改          | 不可变引用的不可变绑定
mut a:&T     | const T* a       | 不能修改a指向的内容 | 不可变引用的可变绑定
a:&mut T     | T* const a       | 不能修改a           | 可变引用的不可变绑定
mut a:&mut T | T*a              | 都能修改            | 可变引用的可变绑定

