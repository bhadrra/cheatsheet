#include<limits.h>
int a=INT_MIN

# custom compare
std::sort(std::begin(container), std::end(container),
          [] (const auto& lhs, const auto& rhs) {
    return lhs.first < rhs.first;
});

//最小堆
priority_queue<int, vector<int>, greater<int> > q;

//字符串匹配
s1.find(s2) != std::string::npos

//unique
std::vector<int> v{1,2,1,1,3,3,3,4,5,4};
auto last = std::unique(v.begin(), v.end());
// v now holds {1 2 1 3 4 5 4 x x x}, where 'x' is indeterminate
v.erase(last, v.end());

// subset of binary
for (int cs = (a - 1) & a; cs; cs = (cs - 1) & a) {
  cout<<cs<<endl;
}

lower_bound
upper_bound
默认数组从小到大排序。如果是从大到小排序，需要加个参数
左开右闭。右边一般是 v.end() 这种访问不了的地方
如果返回右区间，表明没有查询到
使用的时候，想想好是不是一定能找的到。如果一定能找的到，那也不用额外判断了
